From bdc39d88eb04743f19039d8013878034ddbea28d Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Mon, 19 Nov 2012 19:41:35 +0800
Subject: [PATCH 16/26] xilinx_zynq: Add xilinx can emulation

Add xilinx can emulation from qemu-xarm git tree:
git://git.xilinx.com/qemu-xarm.git

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 hw/arm/Makefile.objs |    1 +
 hw/xilinx_can.c      |  127 ++++++++++++++++++++++++++++++++++++++++++++++++++
 hw/xilinx_zynq.c     |    3 ++
 3 files changed, 131 insertions(+)
 create mode 100644 hw/xilinx_can.c

diff --git a/hw/arm/Makefile.objs b/hw/arm/Makefile.objs
index 1e16059..4fd1ece 100644
--- a/hw/arm/Makefile.objs
+++ b/hw/arm/Makefile.objs
@@ -5,6 +5,7 @@ obj-y += xilinx_zynq.o zynq_slcr.o
 obj-y += xilinx_spips.o
 obj-y += zynq_gpio.o
 obj-y += xilinx_devcfg.o
+obj-y += xilinx_can.o
 obj-y += arm_gic.o arm_gic_common.o
 obj-y += realview_gic.o realview.o arm_sysctl.o arm11mpcore.o a9mpcore.o
 obj-y += exynos4210_gic.o exynos4210_combiner.o exynos4210.o
diff --git a/hw/xilinx_can.c b/hw/xilinx_can.c
new file mode 100644
index 0000000..b2cc64c
--- /dev/null
+++ b/hw/xilinx_can.c
@@ -0,0 +1,127 @@
+/*
+ * QEMU dummy model of xilinx can controller
+ *
+ * Copyright (c) 2011 Peter A.G. Crosthwaite (peter.crosthwaite@petalogix.com)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "sysbus.h"
+#include "sysemu.h"
+
+#ifdef XILINX_CAN_ERR_DEBUG
+#define DB_PRINT(...) do { \
+    fprintf(stderr,  ": %s: ", __func__); \
+    fprintf(stderr, ## __VA_ARGS__); \
+    } while (0);
+#else
+    #define DB_PRINT(...)
+#endif
+
+#define R_MAX (0x80/4 + 1) //AFIR4
+
+struct XilinxCan
+{
+    SysBusDevice busdev;
+    MemoryRegion iomem;
+    qemu_irq irq;
+    uint32_t regs[R_MAX];
+};
+
+static void update_ixr (struct XilinxCan *s) {
+    //TODO: implement
+}
+
+static void xilinx_can_reset (struct XilinxCan *s) {
+    memset(s->regs, 0, R_MAX*4);
+}
+
+static uint64_t can_read (void *opaque, uint64_t addr, unsigned size)
+{
+    struct XilinxCan *s = opaque;
+    uint32_t ret;
+
+    addr >>= 2;
+    switch (addr)
+    {
+        //TODO: implement any read side effects
+    }
+    ret = s->regs[addr];
+    DB_PRINT("addr=" TARGET_FMT_plx " = %x\n", addr * 4, ret);
+    return ret;
+}
+
+static void
+can_write (void *opaque, uint64_t addr, uint64_t value, unsigned size)
+{
+    struct XilinxCan *s = opaque;
+    uint32_t mask = 0;
+    DB_PRINT("addr=" TARGET_FMT_plx " = %x\n", addr, (unsigned)value);
+    addr >>= 2;
+    switch (addr)
+    {
+        //TODO: implement register write behaviours
+    }
+    s->regs[addr] = (s->regs[addr] & ~mask) | (value & mask);
+    update_ixr(s);
+}
+
+static const MemoryRegionOps can_ops = {
+    .read = can_read,
+    .write = can_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+static int xilinx_can_init(SysBusDevice *dev)
+{
+    struct XilinxCan *s = FROM_SYSBUS(typeof (*s), dev);
+
+	DB_PRINT("inited device model\n");
+
+    sysbus_init_irq(dev, &s->irq);
+
+    memory_region_init_io(&s->iomem, &can_ops, s, "can", R_MAX*4);
+    sysbus_init_mmio(dev, &s->iomem);
+
+    xilinx_can_reset(s);
+    return 0;
+}
+
+static void xilinx_can_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = xilinx_can_init;
+    dc->reset = xilinx_can_reset;
+}
+
+static TypeInfo xilinx_can_info = {
+    .name           = "xilinx,can",
+    .parent         = TYPE_SYS_BUS_DEVICE,
+    .instance_size  = sizeof(struct XilinxCan),
+    .class_init     = xilinx_can_class_init,
+};
+
+static void xilinx_can_register_types(void)
+{
+    type_register_static(&xilinx_can_info);
+}
+
+type_init(xilinx_can_register_types)
diff --git a/hw/xilinx_zynq.c b/hw/xilinx_zynq.c
index 3d48b9c..2aaa5a7 100644
--- a/hw/xilinx_zynq.c
+++ b/hw/xilinx_zynq.c
@@ -209,6 +209,9 @@ static void zynq_init(QEMUMachineInitArgs *args)
     sysbus_create_varargs("cadence_ttc", 0xF8002000,
             pic[69-IRQ_OFFSET], pic[70-IRQ_OFFSET], pic[71-IRQ_OFFSET], NULL);
 
+    sysbus_create_simple("xilinx,can", 0xE0008000, pic[60-IRQ_OFFSET]);
+    sysbus_create_simple("xilinx,can", 0xE0009000, pic[83-IRQ_OFFSET]);
+
     sysbus_create_simple("cadence_iic", 0xE0004000, pic[57-IRQ_OFFSET]);
     sysbus_create_simple("cadence_iic", 0xE0005000, pic[80-IRQ_OFFSET]);
 
-- 
1.7.9.5

